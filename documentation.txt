Link to course on YouTube:
https://www.youtube.com/watch?v=yyUHQIec83I

================
## First Step ##
================
1. We start with creating main.go
and within it we put a simple command for printing Hello World on the screen.
We can see an error and this is not going to work, because we need to init our project module .

2. For that to happen we execute the following command:
```
go mod init booking-app 
```
which initiates our project and creates a go.mod file which is the module for our project

3. In go everything is organized in packages, so we need to start from that here:
As a first line in our GO application, we define the keyword "package" and then the name of the package,  
which our application will be part of - and the standard name for the main application is main.

4. The next thing expected is declaration, which basically means that GO doesn't know where to start executing the application, it needs an entrypoint.
We have to declare the entrypoint of our application - in which kine the execution of the code starts.
We create a function called main and put the logic within that main function.
```
func main() {
    application logic...
}
```

for one GO application we will have only one main, because we can have only one entry point per application.

5. The next thing we will need to import the packages from which we take our functionalities.
So if we want to use the Print functionality we need to import the fmt package:
```
import "fmt"
```
and then to indicate that object on the Print function as 
```
fmt.Print("")
```

6. In order to know what are the default packages that are within 
the GO installation - visit https://pkg.go.dev/std

7. Println command will print in a new line

======================
## Building our App ##
======================

==========================
Variables and constants - in commit vars and consts
==========================

====================
Formatting output - in commit with this name
====================
We can use place holders for the variables like this - fmt.Printf("something %v something\n", varName)
we change the Println to Printf, and within the quotes we use %v and at the end of the quotes we will need a \n for new line and after the quotes we need to indicate the name of the var

There are other ways to format output with variables - chack the docs https://pkg.go.dev/fmt@go1.25.5
===========
Data types
===========
What happens if we want to use a variable that is yet unknown?
Like using a variable which its value is a user name that the user needs to prompt?

we can define within our
```
func main() {
    var userName
    // ask user for their name

    userName = "Lior"
    fmt.Println(userName)
}
```
But this will result in an error that it expects a data type for the var.
Data types can be Strings, Integers, Booleans, Maps, Arrays ...
So we need to add
```
var userName string
```

## We can print out the types of the variables by using the %T placeholder:

```
fmt.Printf("conferenceTickets is %T, remainingTickets is %T, conferenceName is %T\n", conferenceTickets, remainingTickets, conferenceName)
```

## There are several datatypes for numbers, like float (12.34) and uint(which is only allowing positive numbers)
so we can indicate for the number of tickets the uint data type so it will not go under zero.

## Another way to declare variabels, instead of the first, use the second:

```
var conferenceName = "Go Conference"
conferenceName := "Go Conference"
```

This works with VARS ONLY and not with constants

===================
Getting User Input
===================

In order to get user input we use another function from the fmt package - fmt.Scan()
this function alone doesnt prompt anything for the user and we need to use a pointer (& sign)
```
fmt.Scan(&userName)
```
This pointer makes the value availble in our code for use.

====================
Book ticket Logic
====================
This is quite simple - we reduce the number of userTickets from the remainingTickets,
but since data types needs to be the same to perform this reduction, we will also change the userTickets to uint data type

```
remainingTickets = remainingTickets - userTickets
```

================
Arrays
================
We will create an Array for all the bookings
the array in GO is fixed size, meaning we need to define the maximum size for it within []
this size indicates how many elements this array can hold
```
var bookings = [50]
```

The next thing we need to define is the type of the elements this aaray will contain.
We want to save the name of the user who booked the ticket, which is a string.
```
var bookings = [50]string
```

Finally, we will need the actual value - we can assign an empty array or assign a few names:
```
```
var bookings = [50]{"Lior", "Inbal", "Nana"}
```
Because we define a data type for the array, we have to use the defined data type and we cannot mix datatypes.
Usually we will start with an empty list

If we want to define an Array and use variables, first we remove the "=" sign and we dont use the {}:

```
var bookings [50]string
```

and then we start filling it up with the username:

```
bookings[0] = firstName + " " + lastName
```
but we will need to use it ONLY AFTER these variables had been declared, so further down the code


===========
Slices
===========

What if we don't know in advance the size we would need for the array?
we need a list that is more dynamic in size.

Slice is an abstraction of an Array
It uses the array type under the hood but it uses a dynamic size.

Working with slices is more efficient than working with arrays, so using slices is a better option.

A slice is an array without a size definition.
```
var bookings []string
```

While in arrays we use indexes (bookings[0]), slices adds the next elemnt to the list.
```
bookings = append(bookings, firstName + " " + lastName)
```

=======
Loops
=======
For repetitive tasks, for executing a code multiple times.
We have only "for" loop (no while, for-each or do-while) for all usecases.

Currently in our app, there is no data persistence - the app is asking for one user to book tickets and then exits.
In order for the names to accumulate, we will create an infinite loop on the booking tickets logic.

for loop syntax is
```
for {}
```
and all the logic we want repetead will be within the {}

================
For-each Loops
================

Currently our code prints out the bookings list which contains the full name of the user.
Let's say we want to show only the first name, so we need to do a repetetive ttask for each of the names and get only the first name within the bookings list.

First we want to create a list, an array of first names:
```
firstNames := []string{}
```

then we want to go through each entry and separate first from last by the space,
so we use here another (nested) for-loop that goes through the newly inserted entry of bookings list,
takes the value of that entry and gets it under some variables chain:
```
firstNames := []string{}
for index, booking := range bookings {} 
```
This additional line iterates on bookings list and each index's value is now under placeholder of booking (the index itself is also a variable!).
bookings is the range, the parent array on which we iterate.

within that:
```
firstNames := []string{}
for index, booking := range bookings {
    var names = strings.Fields(booking)
    var firstName = names[0]
}
```
What did we add?
for each iteration, or for each entry/index, we will create a variable called names that will divide the booking value into Fields
which will be separated as indexes so we can catch the first index under variable firstName from index 0 of names (names[0])

For the last thing here, we want to add the firstName to firstNames list:
```
firstNames := []string{}
for index, booking := range bookings {
    var names = strings.Fields(booking)
    var firstName = names[0]
    firstNames = append(firstNames, firstName)
}
```

and to make it shorter we can cut the following line\logic:
```
firstNames := []string{}
for index, booking := range bookings {
    var names = strings.Fields(booking)
    firstNames = append(firstNames, names[0])
}
```

Now - the index (in for index, booking := range bookings {})
is a placeholder that is empty and has no value, but we need that space.
Since that placeholder is in no use, the code errors.
GO has a solution for that - underscore (_) and this line hsould actually be 
```
for _, booking := range bookings {}
```

=================
If Else
=================
Lets examine our app logic. The app will loop infinitely on booking tickets.
How do we end it? We need it to stop when tickets are sold out.
after every booking we need to check if the remaining tickets is zero and if it is, we end the application.

We do that using if - else checks.

at the end of the booking, within our infinite for loop, we make the check to see if the remaining tickets are zero.

```
if remainingTickets == 0 {}
```
the data type of such conditional statement is a boolean (TRUE or FALSE).
So we're telling the program - if this condition is true, execute the code within the {} of the if block

If the condition is not treu, skip the execution of this code within the {} and skip to the next line,
which in our case is skip to the next iteration of our for loop.

So - If this condition is true and the remaining tickets = zero,
we want a logic to end this program - break command:
```
if remainingTickets == 0 {
	fmt.Println("Our conference is booked out. Come back next year!")
	break
}
```
We can define a variable of boolean type and use it like that:
```
var noTicketsRemaining bool = remainingTickets == 0
if noTicketsRemaining {
	fmt.Println("Our conference is booked out. Come back next year!")
	break
}
```

or simply:
```
noTicketsRemaining := remainingTickets == 0
```
BUT - since we use this variable only once, there's no need for it.

### OverBooking
Currently - if a user tries to book over the remaining tickets, he will get an odd message and the loop won't break:
-- 18446744073709551610 remaining tickets for the Go Conference
We need to check the the userTickets is smaller than the remainingTickets and create the logic for that:
```
if userTickets > remainingTickets {
    fmt.Printf("We only have %v tickets remaining, so you can't book %v tickets\n", remainingTickets, userTickets)
}
```

In addition to inform the user about this we should stop the app, break the code, because if this condition is true,
the tickets should not be booked. But we don't really want to break the app, we want to let the user book again with the correct amount, so instead of break we use continue
and thus it skips the booking and starts the for loop again

if we want to check the reveresed condition, in which the user wants to buy less tickets than remaining or the exact number?
we change the condition to:

```
if userTickets <= remainingTickets {}
```

If this logic is true, then the user can book the tickets, so we put inside the {} the wole logic for booking tickets.

what about the code we already had in the {} ?
```
fmt.Printf("We only have %v tickets remaining, so you can't book %v tickets\n", remainingTickets, userTickets)
```
first we take it out of the {}.

Then we put all the logic within the new if statement,

create an else{} condition
and put this - 	fmt.Printf("We only have %v tickets remaining, so you can't book %v tickets\n", remainingTickets, userTickets)
 within the else{}
 and we can omit the continue, because it will be done anyway.


===========
else if
===========

Let's say we wanted to do a completely different thing if userTickets = remainingTickets,
something that is different from the if block logic or the else block logic. Where would we put it?

In that case we would split up the condition
```
if userTickets <= remainingTickets {}
```
to  
```
if userTickets < remainingTickets {}
```
and add at the end of this if block else if{} block as follows:
```
else if userTickets == remainingTickets{
    do something else
}
```

We will not implement this as it is not required for our code but basically -
an If statement will open and an else statement will close it and in between we can have else ifs

==========================
Conditionals in For Loop
=========================

Execute the code in a loop for as long as a specific condition is true.
Examples:
for remainingTickets > 0 {}
for len(bookings) < 50 {}

=========================
user validation
======================

===================
Switch statements
===================

If our conference is being held in 6 different cities and for each city the logic for booking tickets is different,
The user should first have to choose a city, and based on his choise, it switches to the corresponding code:
```
city := "London"

switch city {
    case "New York":
        // execute code for booking New York conference tickets
    case "Singapore":
        // execute code for booking Singapore conference tickets
    case "London":
        // execute code for booking London conference tickets
    case "Berlin":
        // some code here 
    case "Mexico City":
        // some code here
    case "Hong Kong":
        // some code here
    default:
        fmt.Print("No valid city selected") 
}
```

Now, if some cities have the same logic code for booking we can consolidate it as follows:
```
city := "London"

switch city {
    case "New York":
        // execute code for booking New York conference tickets
    case "Singapore", "Hong Kong":
        // execute code for booking Singapore & Hong Kong conference tickets
    case "London", "Berlin":
        // execute code for booking London & Berlin conference tickets
    case "Mexico City":
        // some code here
    default:
        fmt.Print("No valid city selected") 
}
```

=========================
functions and parameters
=========================

see diffs in main.go to see how the function takes a piece of the code and makes it independent function that can be used within the code.


=================================
Returning values from functions
=================================

We will take the firstName function:
```
func printFirstNames(bookings []string) {
	firstNames := []string{}
	for _, booking := range bookings {
		var names = strings.Fields(booking)
		firstNames = append(firstNames, names[0])
	}
	fmt.Printf("The first names of bookings are: %v\n", firstNames)
}
```

and we want the final printing to be done from the main function and not from this one,
so instead of printing the names, we want this function to just return the first names to the main function,
so the main function can print it itself.

So instead of the print line, we will use:

```
return firstNames
```

now this function is doing some logic, and returning a result of that logic to the main function.
Whenever we return something in a function, we have to say it in the function definition,
and that we are returning a value of a certain type, and in our case, firstNames are also a slice of string.

```
func printFirstNames(bookings []string) []string {
    \\\ rest of the logic...
}
```

NOTICE that within these brackets () we have input parameters
and outside it its output parameters with the type of output we're returning.

And the print line should go back to the main function.

we will also need a variable to get these values, so firstNames(bookings) will become:
```
firstNames := getFirstNames(bookings)
```

--------

User Input validation can also be a candidate for its own function

===========================
Package level variables
===========================
I our app, we want to take the variables and let multiple functions, including the main - have access to them.
These variables will be defined outside all the functions.

the variables would need the full var syntax:
```
conferenceName := "Go Conference"
```
will become 
```
var conferenceName = "Go Conference"
```

and then we don't need to pass variables like this:
```
greetUsers(conferenceName, conferenceTickets, remainingTickets)
```

because it has a direct access to them
We also need to change the variables in the code so they would match the global ones

=============================
More use cases of Functions
=============================
1. Group logic that belongs together
2. Reuse logic and reducing code duplication

For an example - having the conference in multiple locations, we can call the Validate user input function in each.

=========
Packages
=========

We've been working with one file only. What if we want to write more complexed application with a lot of logic?
We created one package - main which has a main.go file, but we can create multiple packages in one go file.
We will go back to the conference's multiple locations, and each location can have its own package and then we can share the same logic code between them.

we can set an helper.go or common.go or shared.go file that will take functions from the main file and hand it or make it available for the other files.

let's create a helper.go file,
state the package main and move the validateUserInput function there.
We would also need to import the strings package for it o work.

No other change is required in our main.go file - it knows where to find that information in helper.go

but we can't use the command
```
go run main.go
```
because it will not have the function we moved to the helper.go.
Therefore, we need to run all the files:

```
go run main.go helper.go
```

since it is not that convenient to pass all the file names in the go run command,
we can siimply pass the folder:
```
go run .
```

==================
Multiple Packages
==================
We can also have other packages that belong to the application.
What can be a use case for that? Booking app for different conferences.
Booking logic for these confereneces is completely diffferent.

We create package for each location, and in case there's some logic that they all share, it can be a separate common.go package.

Let's move our helper.go to its own package.
It is common practice to have a dedicated folder for each package
we will move this whole function logic to helper.go:
```
func validateUserInput()
```

Once we moved helper.go to helper folder and to its own package, tha mani function doesn't recognize the validateUserInput function,
it doesn't know where it is anymore.

we would need to import the package and then we would be able to use the functions inside it.

But we can't import our own made package like we import default packages.
We need to use the module name created in our go.mod to import it like that:
```
import "booking-app/helper"
```

and when we call the function, we need to indicate the package name:
```
helper.validateUserInput
```

We also need to export the helper package - It is very simple to do,
we just capitalize the first letter of the function
```
func ValidateUserInput()
```

We can do the same for variables, and we will also Capitalize them.

==============
Scope Rules
==============
Local - within functions or code blocks (in a for loop) - available ONLY within the functions/blocks
Package - Defining variables on the package level outside the functions, so all functions within the package can use it.
Global - creating a variable file and using a variable capitalized name within it.

===========
Maps (2:38:00)
===========

we will revert our helper package back to main for simplicity

Right now, whaen a user is booking a ticket, we keep only his full name in the bookings list.
But the email address and the number of tickets they provided, gets ignored, it is not being saved.
we want to save this information as well.

In our case, bookings is a slice, that allows us to save a list of string values.
But instead of a string, we want a datatype with multiple key:value pairs per user.
Something like that:
```
firstName: "Lior"
lastName: "Milliger"
email: "liorm@email"
tickets: 3
```

a datatype that will allow storing multiple key:value pairs per user, is called a map.

Let's see how we can turn our bookings list from a list of strings to a list of maps.

We will first go to the bookTicket function and create a map for a user:

Map is a datatype and just like with any other datatype we create a variable with an empty map.
how do we create a map? First of all we have a keyword "map" and then we have to define types for key and value: 
```
var userData = map[string]string
```
This only defines the type of the map. We need to create an empty map.
We need an expression that is creating an empty map. for that, we have a built in function that is called make()
```
var userData = make(map[string]string)
```
That would give us an empty map. For the next step, we want to add all the user data 
How do we add value:key data to a map? 
nameOfTheMap["key"] = value (of the variable)

```
var userData = make(map[string]string)
userData["firstName"] = firstName
userData["lastName"] = lastName
userData["email"] = email
```

These are all strings, but we want also to add the number of tickets, but its datatype is uint and we can't mix datatypes, so what FormatUint
that comes from package strconv - so strconv.FormatUint()
We need to call the variable but there's another function needs to be used to transform that number, and Nana does not explain much about it
and it looks like that:
```
strconv.FormatUint(uint64(userTickets), 10)
```

Now we need to take that map and add it to the bookings list.
Bookings is a slice of strings and we need to change it to a slice of maps:
```
var bookings = make([]map[string]string, 0)
```

we add the make() in order to create an empty slice of maps, and we also add the zero, because it needs to know the initial size of the list of maps.
It will increase automatically, but we need to assign the first value here like that.

With this syntax we're initializing a list of maps.

Finally for the last step, we go to our book ticket logic:
```
bookings = append(bookings, userData)
```

we also need to change the function that gets the firstName to get the correct value from the map:
```
func getFirstNames() []string {
	firstNames := []string{}
	for _, booking := range bookings {
		firstNames = append(firstNames, booking["firstName"])
	}
	return firstNames
}
```

========================
Struct datatype 2:53:00
========================
Collecting different datatypes in key:value pairs.
The struct can work as separate entities that each contain different data in various (and mixed) datatypes, as opposite to maps,
in which datatypes cannot be mixed.

In our app we will create it outside of the function, in the package level.
we declare the struct and within the {} we define the list of keys (without "") and the type of the value for each:
```
struct {
    firstName string
    lastName string
    email string
    numberOfTickets uint
}
```

we can also use a boolean or any other type we would want/need.

we would need a name for our struct - let's call it userData,
and finally, to ceate the struct datatype, we would need to use the "type" keyword at the beginning.
```
type userData struct {}
```
we create a custom type named userData.
struct (structure) enable us to create a pre-defined structure by listing all the properties it should have.

----

In order to use our userData struct instead of the map,
we would need to make some changes to our code - see in diff:

```
var bookings = make([]map[string]string, 0)
```
becomes
```
var bookings = make([]userData, 0)
```

we also need to create this in the bookTicket function (line 97 in main.go)
The map structure is being replaced by the struct structure.

One more thing to change is in the getFirstNames function, and its the way we get the first name out of the map - which is now a struct (line 66)

=========================
Concurrency (Go Routines)
=========================
After the user is booking a ticket, we would want to send him a ticket to the email address he added.
we would create a function sendTicket that sends the ticket to the email entered.
we would use a simple fmt.Printf with the variables and pass them in the function as well:
```
func sendTicket(userTickets uint, firstName string, lastName string){
    fmt.Printf("%v tickets for %v %v\n". userTickets, firstName, lastName)
}
```

Let's say we want to save it as a variable called ticket and send it per email,
so we would use a different function from th eformat package which is called Sprintf:
```
func sendTicket(userTickets uint, firstName string, lastName string){
   var ticket = fmt.Sprintf("%v tickets for %v %v\n". userTickets, firstName, lastName)
}
```

we would also want to use this function in the main function, so right after bookTicket we would call it.

Since it is going to take some time to generate and send the ticket, we want to simulate the time it takes,
so we would use a sleep of 10 seconds command, taken from time package (that we would need to add to the packages)
```
time.Sleep(10 * time.Second)
```

The code will be blocked for 10 seconds until the send message will appear.
How do we handle this block?

#####################################
Handle code blocking with Goroutines
#####################################

If this application needs to serve multiple users at a time this is not an optimal performance.
we would need to allow another user to book tickets in parallel.

Our code is running on one thread, one function after the other one, and only when a function finishes its execution, the next one will be executed.
When we know something takes longer to be executed, we want to start a separate thread for it,
and execute its logic in a separate thread.
it is as simple as adding "go" before the calling of the function:
```
go sendTickets(variables)
```


