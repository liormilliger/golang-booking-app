================
## First Step ##
================
1. We start with creating main.go
and within it we put a simple command for printing Hello World on the screen.
We can see an error and this is not going to work, because we need to init our project module .

2. For that to happen we execute the following command:
```
go mod init booking-app 
```
which initiates our project and creates a go.mod file which is the module for our project

3. In go everything is organized in packages, so we need to start from that here:
As a first line in our GO application, we define the keyword "package" and then the name of the package,  
which our application will be part of - and the standard name for the main application is main.

4. The next thing expected is declaration, which basically means that GO doesn't know where to start executing the application, it needs an entrypoint.
We have to declare the entrypoint of our application - in which kine the execution of the code starts.
We create a function called main and put the logic within that main function.
```
func main() {
    application logic...
}
```

for one GO application we will have only one main, because we can have only one entry point per application.

5. The next thing we will need to import the packages from which we take our functionalities.
So if we want to use the Print functionality we need to import the fmt package:
```
import "fmt"
```
and then to indicate that object on the Print function as 
```
fmt.Print("")
```

6. In order to know what are the default packages that are within 
the GO installation - visit https://pkg.go.dev/std

7. Println command will print in a new line

======================
## Building our App ##
======================

==========================
Variables and constants - in commit vars and consts
==========================

====================
Formatting output - in commit with this name
====================
We can use place holders for the variables like this - fmt.Printf("something %v something\n", varName)
we change the Println to Printf, and within the quotes we use %v and at the end of the quotes we will need a \n for new line and after the quotes we need to indicate the name of the var

There are other ways to format output with variables - chack the docs https://pkg.go.dev/fmt@go1.25.5
===========
Data types
===========
What happens if we want to use a variable that is yet unknown?
Like using a variable which its value is a user name that the user needs to prompt?

we can define within our
```
func main() {
    var userName
    // ask user for their name

    userName = "Lior"
    fmt.Println(userName)
}
```
But this will result in an error that it expects a data type for the var.
Data types can be Strings, Integers, Booleans, Maps, Arrays ...
So we need to add
```
var userName string
```

## We can print out the types of the variables by using the %T placeholder:

```
fmt.Printf("conferenceTickets is %T, remainingTickets is %T, conferenceName is %T\n", conferenceTickets, remainingTickets, conferenceName)
```

## There are several datatypes for numbers, like float (12.34) and uint(which is only allowing positive numbers)
so we can indicate for the number of tickets the uint data type so it will not go under zero.

## Another way to declare variabels, instead of the first, use the second:

```
var conferenceName = "Go Conference"
conferenceName := "Go Conference"
```

This works with VARS ONLY and not with constants

===================
Getting User Input
===================

In order to get user input we use another function from the fmt package - fmt.Scan()
this function alone doesnt prompt anything for the user and we need to use a pointer (& sign)
```
fmt.Scan(&userName)
```
This pointer makes the value availble in our code for use.

====================
Book ticket Logic
====================
This is quite simple - we reduce the number of userTickets from the remainingTickets,
but since data types needs to be the same to perform this reduction, we will also change the userTickets to uint data type

```
remainingTickets = remainingTickets - userTickets
```

================
Arrays
================
We will create an Array for all the bookings
the array in GO is fixed size, meaning we need to define the maximum size for it within []
this size indicates how many elements this array can hold
```
var bookings = [50]
```

The next thing we need to define is the type of the elements this aaray will contain.
We want to save the name of the user who booked the ticket, which is a string.
```
var bookings = [50]string
```

Finally, we will need the actual value - we can assign an empty array or assign a few names:
```
```
var bookings = [50]{"Lior", "Inbal", "Nana"}
```
Because we define a data type for the array, we have to use the defined data type and we cannot mix datatypes.
Usually we will start with an empty list

If we want to define an Array and use variables, first we remove the "=" sign and we dont use the {}:

```
var bookings [50]string
```

and then we start filling it up with the username:

```
bookings[0] = firstName + " " + lastName
```
but we will need to use it ONLY AFTER these variables had been declared, so further down the code


===========
Slices
===========

What if we don't know in advance the size we would need for the array?
we need a list that is more dynamic in size.

Slice is an abstraction of an Array
It uses the array type under the hood but it uses a dynamic size.

Working with slices is more efficient than working with arrays, so using slices is a better option.

A slice is an array without a size definition.
```
var bookings []string
```

While in arrays we use indexes (bookings[0]), slices adds the next elemnt to the list.
```
bookings = append(bookings, firstName + " " + lastName)
```

=======
Loops
=======
For repetitive tasks, for executing a code multiple times.
We have only "for" loop (no while, for-each or do-while) for all usecases.

Currently in our app, there is no data persistence - the app is asking for one user to book tickets and then exits.
In order for the names to accumulate, we will create an infinite loop on the booking tickets logic.

for loop syntax is
```
for {}
```
and all the logic we want repetead will be within the {}

================
For-each Loops
================

Currently our code prints out the bookings list which contains the full name of the user.
Let's say we want to show only the first name, so we need to do a repetetive ttask for each of the names and get only the first name within the bookings list.

First we want to create a list, an array of first names:
```
firstNames := []string{}
```

then we want to go through each entry and separate first from last by the space,
so we use here another (nested) for-loop that goes through the newly inserted entry of bookings list,
takes the value of that entry and gets it under some variables chain:
```
firstNames := []string{}
for index, booking := range bookings {} 
```
This additional line iterates on bookings list and each index's value is now under placeholder of booking (the index itself is also a variable!).
bookings is the range, the parent array on which we iterate.

within that:
```
firstNames := []string{}
for index, booking := range bookings {
    var names = strings.Fields(booking)
    var firstName = names[0]
}
```
What did we add?
for each iteration, or for each entry/index, we will create a variable called names that will divide the booking value into Fields
which will be separated as indexes so we can catch the first index under variable firstName from index 0 of names (names[0])

For the last thing here, we want to add the firstName to firstNames list:
```
firstNames := []string{}
for index, booking := range bookings {
    var names = strings.Fields(booking)
    var firstName = names[0]
    firstNames = append(firstNames, firstName)
}
```

and to make it shorter we can cut the following line\logic:
```
firstNames := []string{}
for index, booking := range bookings {
    var names = strings.Fields(booking)
    firstNames = append(firstNames, names[0])
}
```

Now - the index (in for index, booking := range bookings {})
is a placeholder that is empty and has no value, but we need that space.
Since that placeholder is in no use, the code errors.
GO has a solution for that - underscore (_) and this line hsould actually be 
```
for _, booking := range bookings {}
```